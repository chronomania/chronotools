<html><head><meta http-equiv="Content-type" content="text/html; charset=iso-8859-1">
 <title>Command line argument handling library</title>
 <style type="text/css"><!--
TABLE.toc {border:0px}
A:link,A:visited{text-decoration:none;color:#2A3B83}
A:hover{text-decoration:underline;color:#002040}
A:active{text-decoration:underline;color:#004060;background:#CCD8FF}
TD.toc   {font-size:80%; font-family:Tahoma; text-align:left}
H1       {font-size:250%; font-weight:bold} .level1 {text-align:center}
H2       {font-size:200%; font-weight:bold} .level2 {margin-left:1%}
H3       {font-size:160%; font-weight:bold} .level3 {margin-left:2%}
H4       {font-size:145%; font-weight:bold} .level4 {margin-left:3%}
H5       {font-size:130%; font-weight:bold} .level5 {margin-left:4%}
H6       {font-size:110%; font-weight:bold} .level5 {margin-left:5%}
BODY{background:white;color:black}
CODE{font-family:lucida console,courier new,courier;color:#105000}
PRE.smallerpre{font-family:lucida console,courier new,courier;font-size:80%;color:#500010;margin-left:30px}
SMALL    {font-size:70%}
--></style></head>
 <body>
  <h1>Command line argument handling library</h1>
  <h2 class=level2> 0. Contents </h2>
  
  This is the documentation of libargh-1.0.8.
<div class=toc><table cellspacing=0 cellpadding=0 class=toc><tr><td width="50%" valign=middle align=left nowrap class=toc>&nbsp;&nbsp;&nbsp;1. <a href="#h0">Purpose</a><br>&nbsp;&nbsp;&nbsp;2. <a href="#h1">Supported</a><br>&nbsp;&nbsp;&nbsp;3. <a href="#h2">Headers</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1. <a href="#h3">C++ header: argh.hh</a><br></td>
<td width="50%" valign=middle align=left nowrap class=toc>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2. <a href="#h4">C header: argh.h</a><br>&nbsp;&nbsp;&nbsp;4. <a href="#h5">Copying</a><br>&nbsp;&nbsp;&nbsp;5. <a href="#h6">Requirements</a><br>&nbsp;&nbsp;&nbsp;6. <a href="#download">Downloading</a><br></td>
</tr></table></div><H2 id="h0" class="level2"><a name="h0"></a>1. Purpose</H2><div class="level2" id="divh0">

Handles commandline parameters.

</div><H2 id="h1" class="level2"><a name="h1"></a>2. Supported</H2><div class="level2" id="divh1">

C, C++

</div><H2 id="h2" class="level2"><a name="h2"></a>3. Headers</H2><div class="level2" id="divh2">

</div><H3 id="h3" class="level3"><a name="h3"></a>3.1. C++ header: argh.hh</H3><div class="level3" id="divh3">

<pre class=smallerpre>#ifndef optrar_argh_hh
#define optrar_argh_hh

/* Copyright (C) 1992,2003 Bisqwit (http://iki.fi/bisqwit/) */

/*
 * C++ USAGE EXAMPLE
 * 

#include &lt;argh.hh&gt;

int main(int argc, const char *const *argv)
{
    vector&lt;string&gt; files;
    
    string buildfn;
    bool worst = false;
    
    ParamHandler Argh;
    
    Argh.AddLong(&quot;worst&quot;,   'w').SetBool().SetDesc(&quot;Least optimal.&quot;);
    Argh.AddLong(&quot;help&quot;,    'h').SetBool().SetDesc(&quot;This help.&quot;);
    Argh.AddLong(&quot;version&quot;, 'V').SetBool().SetDesc(&quot;Displays version information.&quot;);
    Argh.AddLong(&quot;build&quot;,   'b').SetString().SetDesc(&quot;Builds the archive.&quot;, &quot;&lt;file&gt;&quot;);
    Argh.AddLong(&quot;make&quot;,    'b');
    
    Argh.AddBool('k');
    Argh.AddDesc('k', &quot;This option does nothing.&quot;);
    Argh.AddLong(&quot;idle&quot;, 500).SetDesc(&quot;This option does nothing.&quot;);
    
    Argh.StartParse(argc, argv);
    for(;;)
    {
        int c = Argh.GetParam();
        if(c == -1)break;
        switch(c)
        {
            case 'w': worst = Argh.GetBool(); break;
            case 'V': printf(&quot;%s\n&quot;, VERSION); return 0;
            case 'b': buildfn = Argh.GetString(); break;
            case 'k': break; // -k
            case 500: break; // --idle
            case 'h':
                printf(
                    &quot;This is software\n&quot;
                    &quot;\nUsage: software [&lt;option&gt; [&lt;...&gt;]] &lt;file&gt; [&lt;...&gt;]\n&quot;
                    &quot;\nThis software does something for the files.\n&quot;
                    &quot;\nOptions:\n&quot;);
                Argh.ListOptions();
                printf(&quot;\nNo warranty whatsoever.\n&quot;);
                return 0;
            default:
                files.push_back(Argh.GetString());
        }
    }
    if(!Argh.ok())return -1;
    if(!files.size())
    {
        fprintf(stderr, &quot;Error: At least one file must be specified.\n&quot;);
        return -1;
    }
    
    ...
}

*/

/* The header begins here. */

#include &lt;string&gt;
class ParamHandler
{
private:
    /* No copying */
    void operator=(const ParamHandler &amp;);
    ParamHandler (const ParamHandler &amp;);
    class Reference;
public:
    typedef long keytype;
    
    ParamHandler();
    virtual ~ParamHandler();
    virtual void PrintOpt(unsigned space, const std::string &amp;opts, const std::string &amp;desc);
    
    Reference AddLong(const std::string &amp;longname, keytype alias);
    Reference AddBool(keytype c);
    Reference AddInt(keytype c, int min, int max);
    Reference AddFloat(keytype c, double min, double max);
    Reference AddString(keytype c, unsigned min=1, unsigned max=std::string::npos);
    Reference AddDesc(keytype c, const std::string &amp;s, const std::string &amp;param=&quot;&quot;);

    // Support for many conventions
    void StartParse(int ac, const char *const *av, int firstarg=1);
    void StartParse(int ac, const char **av, int firstarg=1);
    void StartParse(int ac, char **av, int firstarg=1);
    void StartParse(int ac, char *const*av, int firstarg=1);
    
    const std::string ProgName() const { return A0; }

    /* --not-x, --no-x, --without-x and --with-x are recognized.
     * Therefore you should use GetBool().
     */
    inline const bool GetBool() const      { return polarity; }
    inline const int GetInt() const        { return intparm; }
    inline const double GetFloat() const   { return doubleparm; }
    inline const std::string &amp;GetString() const { return param; }
    inline const bool ok() const           { return !error; }
    
    keytype GetParam();
    void ListOptions();

private:
    static inline keytype char2opt(char c1, char c2) { return (unsigned char)c1 + (unsigned char)c2 * 256; }
    static inline keytype char3opt(char c1, char c2, char c3) { return (unsigned char)c1 + 256 * char2opt(c2, c3); }
    
    void ErrorIllegalOption(keytype key);
    void ErrorNeedsArg(keytype key);
    void ErrorNeedsArg(const std::string &amp;longo);
    void ErrorNeedNoArg(const std::string &amp;longo);
    void InternalError(keytype key, const char *s);
    void ErrorOutOfRange(const std::string &amp;param);
    void ErrorUnknownOption(const char *s, bool negafail);
        
public:
    /* argh_atypemap needs this and I don't know how to make it friend. */
    class ArgInfo { public: char type; int min,max;unsigned maxl;double fmin,fmax; };
private:
    class argh_aliasmap *aliases;
    class argh_descsmap *descs;
    class argh_atypemap *argtypes;
    class Reference
    {
        ParamHandler *par;
        keytype key;
    public:
        Reference(ParamHandler *p, keytype k) : par(p), key(k) { }
        Reference &amp;SetBool();
        Reference &amp;SetInt(int min, int max);
        Reference &amp;SetFloat(double min, double max);
        Reference &amp;SetString(unsigned min=1, unsigned max=std::string::npos);
        Reference &amp;SetDesc(const std::string &amp;s, const std::string &amp;param=&quot;&quot;);
    };
    Reference MakeRef(keytype key);
    int ParseError();
    int ShortOpt(keytype key, const char *s);
private:
    int argc; const char *const *argv;
    const char *A0;
    /* parser volatile */
    int argpos; bool opts; std::string longo, longobuf; std::string param;
    const char *shortpointer; bool error, polarity; int intparm; double doubleparm;
};

#endif
</pre>

</div><H3 id="h4" class="level3"><a name="h4"></a>3.2. C header: argh.h</H3><div class="level3" id="divh4">

<pre class=smallerpre>#ifndef optrar_argh_h
#define optrar_argh_h

/* Copyright (C) 1992,2003 Bisqwit (http://iki.fi/bisqwit/) */

#ifdef __cplusplus
extern &quot;C&quot; {
#endif

extern void argh_init(void);
extern void argh_done(void);
extern void argh_add_long(const char *longname, int alias);
extern void argh_add_bool(int alias);
extern void argh_add_int(int c, int min, int max);
extern void argh_add_float(int c, double min, double max);
extern void argh_add_string(int c, unsigned minlen, unsigned maxlen);
extern void argh_add_desc(int c, const char *s, const char *optparam);
extern void argh_start_parse(int argc, const char *const *argv);
extern int argh_get_bool(void);
extern int argh_get_int(void);
extern double argh_get_float(void);
extern int argh_ok(void);
extern int argh_get_param(void);
extern void argh_list_options(void);
/* Note: This pointer is only valid until next argh_get_param() call */
/* Attention: Do not try to free() it. */
extern const char *argh_get_string(void);

#ifdef __cplusplus
}
#endif

/* C language usage example: 

static int stereo=0;
static int Rate  =43200;
static char *host = NULL;

static void PrintVersionInfo(void)
{
    printf(&quot;erec - polydriving recording server v&quot;VERSION&quot; (C) 1992,2000 Bisqwit\n&quot;);
}

#include &lt;argh.h&gt;

int main(int argc, const char *const *argv)
{
    int Heelp = 0;
    
    argh_init();
    
    argh_add_long(&quot;stereo&quot;, '2'); argh_add_bool('2'); argh_add_desc('2', &quot;Specifies stereo sound. Default is mono.&quot;, NULL);
    argh_add_long(&quot;mono&quot;,   'm'); argh_add_bool('m'); argh_add_desc('m', &quot;Redundant. It's here for esd compatibility.&quot;, NULL);
    argh_add_long(&quot;rate&quot;,   'r'); argh_add_int('r',18,999999); argh_add_desc('r', &quot;Specifies recording rate. 43200 is default.&quot;, &quot;&lt;num&gt;&quot;);
    argh_add_long(&quot;device&quot;, 'd'); argh_add_string('d',1,1023); argh_add_desc('d', &quot;Specify device.&quot;, &quot;&lt;file&gt;&quot;);
    argh_add_long(&quot;help&quot;,   'h'); argh_add_bool('h'); argh_add_desc('h', &quot;Help&quot;, NULL);
    argh_add_long(&quot;version&quot;,'V'); argh_add_bool('V'); argh_add_desc('V', &quot;Version information&quot;, NULL);
    
    argh_start_parse(argc, argv);
    for(;;)
    {
        int c = argh_get_param();
        if(c == -1)break;
        switch(c)
        {
            case 'V':
                PrintVersionInfo();
                return 0;
            case 'h':
                Heelp = 1;
                break;
            case '2':
                if(argh_get_bool())++stereo;else stereo=0;
                break;
            case 'm':
                if(argh_get_bool())stereo = 0;else ++stereo;
                break;
            case 'r':
                Rate = argh_get_int();
                break;
            case 'd':
                strncpy(Device, argh_get_string(), sizeof Device);
                Device[sizeof(Device)-1] = 0;
                break;
            default:
            {
                const char *s = argh_get_string();
                host = (char *)malloc(strlen(s)+1);
                strcpy(host, s);
            }
        }
    }
    if(!host)host = (char *)&quot;10.104.2.2&quot;;
    
    if(!argh_ok())return -1;
    
    if(Heelp)
    {
        PrintVersionInfo();
        printf(
            &quot;\nAllows multiple applications request recorded data&quot;
            &quot;\nat the same time with different stream attributes.\n&quot;);
        printf(
            &quot;Usage: erec [&lt;options&gt; [&lt;...&gt;]] [&lt;host&gt; | none]\n&quot;
            &quot;Options:\n&quot;);
        argh_list_options();
        printf(&quot;\n&quot;
            &quot;If &lt;host&gt; is other than none, the output will be sent with esdcat.\n&quot;);
        return 0;
    }
    
    ...
}

*/

#endif
</pre>

</div><H2 id="h5" class="level2"><a name="h5"></a>4. Copying</H2><div class="level2" id="divh5">

libargh has been written by Joel Yliluoma, a.k.a.
<a href="http://iki.fi/bisqwit/">Bisqwit</a>,<br>
and is distributed under the terms of the
<a href="http://www.gnu.org/licenses/licenses.html#GPL">General Public License</a> (GPL).

</div><H2 id="h6" class="level2"><a name="h6"></a>5. Requirements</H2><div class="level2" id="divh6">

argh has been written in C++, utilizing the standard template library.<br>
GNU make is required.<br>
libargh compiles without warnings at least on g++ versions 3.0.1 and 3.0.3.

</div><H2 id="download" class="level2"><a name="download"></a>6. Downloading</H2><div class="level2" id="divdownload">
   The official home page of libargh
   is at <a href="http://iki.fi/bisqwit/source/libargh.html">http://iki.fi/bisqwit/source/libargh.html</a>.<br>
   Check there for new versions.
</div> <p align=right><small>Generated from
       <code>progdesc.php</code> (last updated: Sat, 25 Jan 2003 16:52:14 +0200)<br>
  with <code>docmaker.php</code> (last updated: Thu, 13 Feb 2003 15:11:29 +0200)<br>
  at Sat, 27 Sep 2003 16:17:09 +0300</small>
 </p>
</body>
</html>
