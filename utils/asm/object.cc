#include <cstdio>
#include <map>

#include "assemble.hh"
#include "object.hh"
#include "warning.hh"

void Object::Segment::AddByte(unsigned char byte)
{
    //std::fprintf(stderr, "Generated byte %02X\n", byte);
    content.push_back(byte);
}

void Object::Segment::SetByte(unsigned offset, unsigned char byte)
{
    if(offset >= content.size())
    {
        std::fprintf(stderr, "Internal error: Attempt to SetByte(%u,0x%02X) when limit is %u\n",
            offset, byte, content.size());
        return;
    }
    content[offset] = byte;
}


void Object::Segment::ClearLabels(unsigned level)
{
    LabelMap::iterator i = labels.find(level);
    if(i != labels.end()) i->second.clear();
}

bool Object::Segment::FindLabel(const std::string& name, unsigned level,
                                unsigned& result) const
{
    LabelMap::const_iterator i = labels.find(level);
    if(i == labels.end()) return false;
    LabelList::const_iterator j = i->second.find(name);
    if(j == i->second.end()) return false;
    result = j->second;
    return true;
}

bool Object::Segment::FindLabel(const std::string& name) const
{
    for(LabelMap::const_iterator
        i = labels.begin();
        i != labels.end(); ++i)
    {
        LabelList::const_iterator j = i->second.find(name);
        if(j != i->second.end()) return true;
    }
    return false;
}

void Object::Segment::DefineLabel(unsigned level, const std::string& name)
{
    labels[level][name] = GetPos();
}

void Object::Segment::UndefineLabel(const std::string& label)
{
    for(LabelMap::iterator
        i = labels.begin();
        i != labels.end(); ++i)
    {
        i->second.erase(label);
    }
}

void Object::Segment::DumpLabels() const
{
    for(LabelMap::const_iterator
        i = labels.begin();
        i != labels.end(); ++i)
    {
        for(LabelList::const_iterator
            j = i->second.begin();
            j != i->second.end();
            ++j)
        {
            std::fprintf(stderr, " %04X [%u]%s\n",
                j->second, i->first, j->first.c_str());
        }
    }
}

void Object::Fixup::Resolved(SegmentSelection s, unsigned o)
{
    targetseg    = s;
    targetoffset = o;
    
#if 0
    std::fprintf(stderr,
        "Ref '%s' (type %c, offs %04X, value %ld) resolved as %04X\n",
            ref.c_str(), type, homeoffset, value, targetoffset);
#endif
    
    ref.clear();
}

void Object::Fixup::Dump() const
{
    std::fprintf(stderr, "Seg %d:%04X; type %c,value %ld",
        (int)homeseg, homeoffset, type, value);
    if(IsResolved())
        std::fprintf(stderr, " - Target seg %d:%04X\n",
            (int)targetseg, targetoffset);
    else
        std::fprintf(stderr, " - Var '%s' - unresolved\n", ref.c_str());
}

Object::Segment& Object::GetSeg()
{
    switch(CurSegment)
    {
        case CODE: return CodeSeg;
        case DATA: return DataSeg;
        case ZERO: return ZeroSeg;
        case BSS: return BssSeg;
    }
    return CodeSeg;
}

bool Object::FindLabel(const std::string& s) const
{
    return CodeSeg.FindLabel(s)
        || DataSeg.FindLabel(s)
        || ZeroSeg.FindLabel(s)
        || BssSeg.FindLabel(s);
}

void Object::MarkLabelUsed(const std::string& s)
{
    UnusedLabels.erase(s);
}

bool Object::FindLabel(const std::string& name, unsigned level,
               SegmentSelection& seg, unsigned& result) const
{
    if(CodeSeg.FindLabel(name, level, result)) { seg=CODE; return true; }
    if(DataSeg.FindLabel(name, level, result)) { seg=DATA; return true; }
    if(ZeroSeg.FindLabel(name, level, result)) { seg=ZERO; return true; }
    if(BssSeg.FindLabel(name, level, result)) { seg=BSS; return true; }
    return false;
}

void Object::CheckFixups()
{
    // Resolve all fixups so far.
    // It's ok if not all are resolvable.
    
    typedef std::list<Fixup>::iterator fixit;
    
    for(fixit i=Fixups.begin(); i!=Fixups.end(); ++i)
    {
        // If already resolved, skip it
        if(i->IsResolved()) continue;
        
        // Skip it also, if it's not its time yet
        if(i->GetLevel() < CurScope) continue;
        
        const std::string& ref = i->GetName();
        
        for(unsigned scope=CurScope; scope-- > 0; )
        {
            unsigned addr=0;
            SegmentSelection seg;
            if(FindLabel(ref, scope, seg, addr))
            {
                MarkLabelUsed(ref);
                
                i->Resolved(seg, addr);
                break;
            }
        }
    }
}

void Object::StartScope()
{
    ++CurScope;
}

void Object::ClearLabels(Segment& seg, unsigned level)
{
    const Segment::LabelList& labels = seg.GetLabels(level);
    
    for(Segment::LabelList::const_iterator
        i = labels.begin(); i !=labels.end(); ++i)
    {
        if(UnusedLabels.find(i->first) != UnusedLabels.end())
        {
            if(MayWarn("unused-label"))
            {
                std::fprintf(stderr,
                    "Warning: Unused label '%s'\n",
                        i->first.c_str());
            }
            UnusedLabels.erase(i->first);
        }
    }

    seg.ClearLabels(level);
}


void Object::EndScope()
{
    CheckFixups();

    if(CurScope > 0)
    {
        // Forget the labels of this level.
        
        // But never forget the global-level labels.
        if(CurScope > 1)
        {
            ClearLabels(CodeSeg, CurScope-1);
            ClearLabels(DataSeg, CurScope-1);
            ClearLabels(DataSeg, CurScope-1);
            ClearLabels(BssSeg, CurScope-1);
        }
    }
    --CurScope;
}

void Object::AddFixup(char prefix, const std::string& ref, long value)
{
    Fixup tmp(CurSegment, GetSeg().GetPos(),
              prefix, ref, value);
    tmp.SetScopeLevel(CurScope);
    Fixups.push_back(tmp);
}

void Object::DefineLabel(const std::string& label)
{
    std::string s = label;
    // Find out which scope to define it in
    unsigned scopenum = CurScope-1;
    if(s[0] == '+')
    {
        // global label
        s = s.substr(1);
        scopenum = 0;
    }
    while(s[0] == '&' && CurScope > 0)
    {
        s = s.substr(1);
        --scopenum;
    }
    
    if(FindLabel(s))
    {
        std::fprintf(stderr, "Error: Label '%s' already defined\n", s.c_str());
        return;
    }
    
    UnusedLabels.insert(s);
    
    GetSeg().DefineLabel(scopenum, s);
}

void Object::DefineLabel(const std::string& label, unsigned level)
{
    GetSeg().DefineLabel(level, label);
}

void Object::UndefineLabel(const std::string& label)
{
    CodeSeg.UndefineLabel(label);
    DataSeg.UndefineLabel(label);
    ZeroSeg.UndefineLabel(label);
    BssSeg.UndefineLabel(label);
}

void Object::DumpFixups() const
{
    std::list<Fixup>::const_iterator i;
    for(i=Fixups.begin(); i!=Fixups.end(); ++i)
        i->Dump();
}

void Object::DumpLabels() const
{
    std::fprintf(stderr, "Labels in TEXT segment:\n"); CodeSeg.DumpLabels();
    std::fprintf(stderr, "Labels in DATA segment:\n"); DataSeg.DumpLabels();
    std::fprintf(stderr, "Labels in ZERO segment:\n"); ZeroSeg.DumpLabels();
    std::fprintf(stderr, "Labels in  BSS segment:\n");  BssSeg.DumpLabels();
}

void Object::Link()
{
    std::list<Fixup>::iterator i;
    for(i=Fixups.begin(); i!=Fixups.end(); ++i)
    {
        const Fixup& fix = *i;
        
        // Select the segment we're going to tamper with
        CurSegment = fix.GetHomeSeg();
        
        const unsigned     address = fix.GetHomeOffset();
        
        const SegmentSelection seg = fix.GetTargetSeg();
        const unsigned        offs = fix.GetTargetOffset();
              long           value = fix.GetValue();
        const std::string&    name = fix.GetName();
        
        if(!fix.IsResolved())
        {
            if(CurSegment != CODE && CurSegment != DATA)
            {
                std::fprintf(stderr,
                    "Error: Unresolved symbol references (like this '%s')"
                    " are only allowed in the TEXT and DATA segments.\n",
                        name.c_str());
                continue;
            }
        }
        else
        {
            value += offs;
        }
        
        switch(fix.GetType())
        {
            case FORCE_LOBYTE:
            {
                if(fix.IsResolved())
                    GetSeg().R16lo.AddFixup(seg, address);
                else
                    GetSeg().R16lo.AddReloc(address, name);

                GetSeg().SetByte(address, value & 0xFF);
                break;
            }
            case FORCE_HIBYTE:
            {
                Segment::R16hi_t::Type data(address, value & 0xFF);
                if(fix.IsResolved())
                    GetSeg().R16hi.AddFixup(seg, data);
                else
                    GetSeg().R16hi.AddReloc(data, name);

                GetSeg().SetByte(address, (value >> 8) & 0xFF);
                break;
            }
            case FORCE_ABSWORD:
            {
                if(fix.IsResolved())
                    GetSeg().R16.AddFixup(seg, address);
                else
                    GetSeg().R16.AddReloc(address, name);

                GetSeg().SetByte(address,   value & 0xFF);
                GetSeg().SetByte(address+1, (value >> 8) & 0xFF);
                break;
            }
            case FORCE_LONG:
            {
                if(fix.IsResolved())
                    GetSeg().R24.AddFixup(seg, address);
                else
                    GetSeg().R24.AddReloc(address, name);

                GetSeg().SetByte(address,   value & 0xFF);
                GetSeg().SetByte(address+1, (value >> 8) & 0xFF);
                GetSeg().SetByte(address+2, (value >> 16) & 0xFF);
                break;
            }
            case FORCE_SEGBYTE:
            {
                Segment::R24seg_t::Type data(address, value & 0xFFFF);
                
                if(fix.IsResolved())
                    GetSeg().R24seg.AddFixup(seg, data);
                else
                    GetSeg().R24seg.AddReloc(data, name);

                GetSeg().SetByte(address, (value >> 16) & 0xFF);
                break;
            }
            case FORCE_REL8:
            {
                if(!fix.IsResolved())
                {
                    std::fprintf(stderr,
                        "Error: Unresolved short relative '%s'\n", name.c_str()
                                );
                    break;
                }
                
                const long diff = value - (long)address - 1;
                
                if(diff < -0x80 || diff >= 0x80)
                {
                    std::fprintf(stderr,
                        "Error: Short jump out of range (%ld)\n", diff);
                }
                
                GetSeg().SetByte(address, diff & 0xFF);
                
                break;
            }
            case FORCE_REL16:
            {
                if(!fix.IsResolved())
                {
                    std::fprintf(stderr,
                        "Error: Unresolved near relative '%s'\n", name.c_str()
                                );
                    break;
                }

                const long diff = value - (long)address - 2;
                
                if(diff < -0x8000 || diff >= 0x8000)
                {
                    std::fprintf(stderr,
                        "Error: Near jump out of range (%ld)\n", diff);
                }
                
                GetSeg().SetByte(address,   diff & 0xFF);
                GetSeg().SetByte(address+1, (diff >> 8) & 0xFF);
                
                break;
            }
        }
    }
}

namespace
{
    void PutC(unsigned char c, std::FILE* fp)
    {
        std::fputc(c, fp);
    }
    void PutS(const char* s, unsigned n, std::FILE* fp)
    {
        for(unsigned a=0; a<n; ++a)
            PutC(s[a], fp);
    }
    void PutW(unsigned short w, std::FILE* fp)
    {
        PutC(w & 255, fp);
        PutC(w >> 8,  fp);
    }
    
    struct Unresolved
    {
        std::map<std::string, unsigned> str2num;
        std::vector<std::string> num2str;
        unsigned size() const { return num2str.size(); }
        
        void Add(const std::string& name)
        {
            if(str2num.find(name) != str2num.end()) return;
            str2num[name] = num2str.size();
            num2str.push_back(name);
        }
        
        void Put(std::FILE* fp)
        {
            PutW(size(), fp);
            for(unsigned a=0; a<size(); ++a)
                PutS(num2str[a].c_str(), num2str[a].size()+1, fp);
        }
        
        unsigned Find(const std::string& s) const
        {
            return str2num.find(s)->second;
        }
    };
    
    unsigned char GetSegmentID(Object::SegmentSelection s)
    {
        switch(s)
        {
            case Object::CODE: return 2;
            case Object::DATA: return 3;
            case Object::ZERO: return 5;
            case Object::BSS:  return 4;
        }
        return 1; /* eep */
    }
    
    typedef std::map<unsigned, std::string> RelocMap;
    
    void PutReloc(const Object::Segment& seg,
                  struct Unresolved& syms,
                  std::FILE* fp)
    {
        // Address-sorted table of relocs in binary format.
        RelocMap relocs;
        
        #define WalkList(type, which) \
            for(Object::Segment::type##_t::which##List::const_iterator \
                i = seg.type.which##s.begin(); \
                i != seg.type.which##s.end(); \
                ++i)

        WalkList(R16lo, Fixup)
        {
            std::string result;
            result += char(0x20 | GetSegmentID(i->first));
            relocs[i->second] = result;
        }

        WalkList(R16, Fixup)
        {
            std::string result;
            result += char(0x80 | GetSegmentID(i->first));
            relocs[i->second] = result;
        }

        WalkList(R24, Fixup)
        {
            std::string result;
            result += char(0xC0 | GetSegmentID(i->first));
            relocs[i->second] = result;
        }

        WalkList(R16hi, Fixup)
        {
            std::string result;
            result += char(0x40 | GetSegmentID(i->first));
            result += char(i->second.second);
            relocs[i->second.first] = result;
        }

        WalkList(R24seg, Fixup)
        {
            std::string result;
            result += char(0xA0 | GetSegmentID(i->first));
            result += char(i->second.second & 255);
            result += char(i->second.second >> 8);
            relocs[i->second.first] = result;
        }

        WalkList(R16lo, Reloc)
        {
            std::string result;
            unsigned n = syms.Find(i->second);
            result += char(0x20);
            result += char(n & 255);
            result += char(n >> 8);
            relocs[i->first] = result;
        }
        
        WalkList(R16, Reloc)
        {
            std::string result;
            unsigned n = syms.Find(i->second);
            result += char(0x80);
            result += char(n & 255);
            result += char(n >> 8);
            relocs[i->first] = result;
        }
        
        WalkList(R24, Reloc)
        {
            std::string result;
            unsigned n = syms.Find(i->second);
            result += char(0xC0);
            result += char(n & 255);
            result += char(n >> 8);
            relocs[i->first] = result;
        }

        WalkList(R16hi, Reloc)
        {
            std::string result;
            unsigned n = syms.Find(i->second);
            result += char(0x40);
            result += char(n & 255);
            result += char(n >> 8);
            result += char(i->first.second);
            relocs[i->first.first] = result;
        }

        WalkList(R24seg, Reloc)
        {
            std::string result;
            unsigned n = syms.Find(i->second);
            result += char(0xA0);
            result += char(n & 255);
            result += char(n >> 8);
            result += char(i->first.second & 255);
            result += char(i->first.second >> 8);
            relocs[i->first.first] = result;
        }
        
        int addr = -1;
        for(RelocMap::const_iterator i = relocs.begin(); i != relocs.end(); ++i)
        {
            int new_addr = i->first;
            int diff = new_addr - addr;
            if(diff <= 0)
            {
                std::fprintf(stderr, "Eep, diff=%d\n", diff);
            }
            while(diff > 254)
            {
                PutC(255, fp);
                diff -= 254;
            }
            PutC(diff, fp);
            addr = new_addr;
            PutS(i->second.data(), i->second.size(), fp);
        }
        PutC(0, fp);
    }
    
    void PutLabels(const Object::Segment& seg,
                   Object::SegmentSelection segtype,
                   std::FILE* fp)
    {
        const unsigned char segid = GetSegmentID(segtype);
        
        typedef Object::Segment::LabelMap LabelMap;
        const LabelMap& labels = seg.GetLabels();
        
        // Count labels
        unsigned count = 0;
        for(LabelMap::const_iterator i = labels.begin(); i != labels.end(); ++i)
        {
            count += i->second.size();
        }
        
        PutW(count, fp);
        
        // Put labels
        for(LabelMap::const_iterator i = labels.begin(); i != labels.end(); ++i)
        {
            for(Object::Segment::LabelList::const_iterator
                j = i->second.begin();
                j != i->second.end();
                ++j)
            {
                unsigned addr           = j->second;
                const std::string& name = j->first;
                
                PutS(name.c_str(), name.size()+1, fp);
                PutC(segid, fp);
                PutW(addr,  fp);
            }
        }
    }
};

void Object::WriteOut(std::FILE* fp)
{
    static const unsigned short Mode
        = 0x8000   // 65816
        | 0x1000;  // object, not exe
    
    // Put O65 header
    PutS("\1\0o65\0", 6, fp);
    
    // Put Mode
    PutW(Mode, fp);
    
    //text
    PutW(CodeSeg.GetBase(), fp);
    PutW(CodeSeg.GetSize(), fp);
    //data
    PutW(DataSeg.GetBase(), fp);
    PutW(DataSeg.GetSize(), fp);
    //bss
    PutW(BssSeg.GetBase(), fp);
    PutW(BssSeg.GetSize(), fp);
    //zero
    PutW(ZeroSeg.GetBase(), fp);
    PutW(ZeroSeg.GetSize(), fp);
    
    // stack size
    PutW(0x0000, fp);
    
    // no custom headers
    PutC(0, fp);
    
    std::fwrite(&CodeSeg.GetContent()[0], CodeSeg.GetSize(), 1, fp);
    std::fwrite(&DataSeg.GetContent()[0], DataSeg.GetSize(), 1, fp);
    
    Unresolved syms;
    
    // Find unresolved symbols
    for(std::list<Fixup>::const_iterator
        i=Fixups.begin(); i!=Fixups.end(); ++i)
    {
        if(!i->IsResolved())
        {
            const std::string& ref = i->GetName();
            syms.Add(ref);
        }
    }
    
    syms.Put(fp);
    
    PutReloc(CodeSeg, syms, fp);
    PutReloc(DataSeg, syms, fp);
    
    PutLabels(CodeSeg, Object::CODE, fp);
    PutLabels(DataSeg, Object::DATA, fp);
    PutLabels(ZeroSeg, Object::ZERO, fp);
    PutLabels( BssSeg, Object::BSS,  fp);
}

void Object::Dump()
{
    //DumpFixups();
    DumpLabels();
}
