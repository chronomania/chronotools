#include "object.hh"

void Object::Segment::AddByte(unsigned char byte)
{
    //std::fprintf(stderr, "Generated byte %02X\n", byte);
    content.push_back(byte);
}

void Object::Segment::ClearLabels(unsigned level)
{
    std::map<unsigned, LabelList>::iterator i = labels.find(level);
    if(i != labels.end()) i->second.clear();
}

bool Object::Segment::FindLabel(const std::string& name, unsigned level,
                                unsigned& result) const
{
    std::map<unsigned, LabelList>::const_iterator i = labels.find(level);
    if(i == labels.end()) return false;
    LabelList::const_iterator j = i->second.find(name);
    if(j == i->second.end()) return false;
    result = j->second;
    return true;
}

bool Object::Segment::FindLabel(const std::string& name) const
{
    for(std::map<unsigned, LabelList>::const_iterator
        i = labels.begin();
        i != labels.end(); ++i)
    {
        LabelList::const_iterator j = i->second.find(name);
        if(j != i->second.end()) return true;
    }
    return false;
}

void Object::Segment::DefineLabel(unsigned level, const std::string& name)
{
    labels[level][name] = GetPos();
}

void Object::Fixup::Resolved(SegmentSelection s, unsigned o)
{
    targetseg    = s;
    targetoffset = o;
    
    std::fprintf(stderr,
        "Label '%s' (type %c, offs %04X, value %ld) defined as %04X\n",
            ref.c_str(), type, homeoffset, value, targetoffset);
    
    ref.clear();
}

void Object::Fixup::Dump() const
{
    std::fprintf(stderr, "Seg %d:%04X; type %c,value %ld",
        (int)homeseg, homeoffset, type, value);
    if(IsResolved())
        std::fprintf(stderr, " - Target seg %d:%04X\n",
            (int)targetseg, targetoffset);
    else
        std::fprintf(stderr, " - Var '%s' - unresolved\n", ref.c_str());
}

void Object::DumpFixups() const
{
    std::list<Fixup>::const_iterator i;
    for(i=Fixups.begin(); i!=Fixups.end(); ++i)
        i->Dump();
}

Object::Segment& Object::GetSeg()
{
    switch(CurSegment)
    {
        case CODE: return CodeSeg;
        case DATA: return DataSeg;
        case ZERO: return ZeroSeg;
        case BSS: return BssSeg;
    }
    return CodeSeg;
}

bool Object::FindLabel(const std::string& s) const
{
    return CodeSeg.FindLabel(s)
        || DataSeg.FindLabel(s)
        || ZeroSeg.FindLabel(s)
        || BssSeg.FindLabel(s);
}

bool Object::FindLabel(const std::string& name, unsigned level,
               SegmentSelection& seg, unsigned& result) const
{
    if(CodeSeg.FindLabel(name, level, result)) { seg=CODE; return true; }
    if(DataSeg.FindLabel(name, level, result)) { seg=DATA; return true; }
    if(ZeroSeg.FindLabel(name, level, result)) { seg=ZERO; return true; }
    if(BssSeg.FindLabel(name, level, result)) { seg=BSS; return true; }
    return false;
}

void Object::CheckFixups()
{
    // Resolve all fixups so far.
    // It's ok if not all are resolvable.
    
    typedef std::list<Fixup>::iterator fixit;
    
    for(fixit i=Fixups.begin(); i!=Fixups.end(); ++i)
    {
        if(i->IsResolved()) continue;
        
        const std::string& ref = i->GetName();
        
        for(unsigned scope=CurScope; scope-- > 0; )
        {
            unsigned addr=0;
            SegmentSelection seg;
            if(FindLabel(ref, scope, seg, addr))
            {
                i->Resolved(seg, addr);
                break;
            }
        }
    }
#if 0
    // 1. Find where the "ref" refers to
    
    switch(prefix)
    {
        case FORCE_LOBYTE:
        case FORCE_HIBYTE:
        case FORCE_ABSWORD:
        case FORCE_LONG:
        case FORCE_SEGBYTE:
        case FORCE_REL8:
        case FORCE_REL16:
            break;
    }
#endif
}

void Object::StartScope()
{
    ++CurScope;
    CodeSeg.ClearLabels(CurScope-1);
    DataSeg.ClearLabels(CurScope-1);
    ZeroSeg.ClearLabels(CurScope-1);
    BssSeg.ClearLabels(CurScope-1);
}

void Object::EndScope()
{
    CheckFixups();

    --CurScope;
}

void Object::AddFixup(char prefix, const std::string& ref, long value)
{
    Fixup tmp(CurSegment, GetSeg().GetPos(),
              prefix, ref, value);
    Fixups.push_back(tmp);
}

void Object::DefineLabel(const std::string& label)
{
    std::string s = label;
    // Find out which scope to define it in
    unsigned scopenum = CurScope-1;
    if(s[0] == '+')
    {
        // global label
        s = s.substr(1);
        scopenum = 0;
    }
    while(s[0] == '&' && CurScope > 0)
    {
        s = s.substr(1);
        --scopenum;
    }
    
    if(FindLabel(s))
    {
        std::fprintf(stderr, "Error: Label '%s' already defined\n", s.c_str());
        return;
    }
    
    GetSeg().DefineLabel(scopenum, s);
}

void Object::Link()
{
}

void Object::Dump()
{
    DumpFixups();
}
