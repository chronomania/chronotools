; Part of Chronotools - http://bisqwit.iki.fi/source/chronotools.html
;
; Copyright (C) 1992,2003 Bisqwit (http://iki.fi/bisqwit/)
;
; This code draws text using VWF8 (variable width 8pix tall font).
;
; To be assembled with snescom.
;    http://bisqwit.iki.fi/source/snescom.html
;

;   The functions to be called are:
;        DrawS_2bit - for 2bit screens
;        DrawS_4bit - for 4bit screens
;   See DrawS_boot for register usage.


; Note - This file is not really as big as it seems.
;        It only has lots of comments and some unrolled loops!


; Variable addresses:
#define W_DATASIZE $10
; W_DATASIZE must be in zeropage because used during dma init
; Pointers are good to stay there too to be simple.
; And jump addresses can only be used from zeropage.
#define P_STR      $12
#define P_FONT     $15
#define P_TILEBUF1 $18
#define P_TILEBUF2 $1B
#define W_ENDDRAWS $1E
#define W_WRITEOFS $20
; Remember to update ALLOCATE() and UNALLOCATE()
; if you add new variables to the zero-segment.

; NMI uses vars at:
;       $000Dxx
;       $0000Fx
;       $00040x
; so don't mess them.
; FIXME - IRQ unclear


; Params from the caller - must be set:
#define W_TILENUM  $6200
#define W_VRAMADDR $6202

; Tilebuf is at $7E620A - size maximally 11*64 bytes
#define W_ONESIZE  $6204
#define W_ENDX     $6206
#define B_PIXOFFS  $6208
#define B_LENGTH   $6209
#define TILEBUF    $620A

; External symbols - defined by the linker:
;   Font address:
;    TILEDATA_ADDR - CONST
;   Width table address:
;    WIDTH_ADDR    - CONST

.text
.xl

; Define functions for handling the bitness...
#define SET_8_BIT_A()   sep #$20 : .as
#define SET_16_BIT_A()  rep #$20 : .al
#define SET_8_BIT_X()   sep #$10 : .xs
#define SET_16_BIT_X()  rep #$10 : .xl

#define SET_8_BIT_AX()  sep #$30 : .xs : .as
#define SET_16_BIT_AX() rep #$30 : .xl : .al

; Input for DrawS_*bit functions:
;    Ah:Y = Address of the string
;    Al   = Maximum length of the string (nul terminates earlier)
;    DB:X = Where to put the tile indices

; ENTRY - Draw string, create 2bit tiles
DrawS_2bit:
        jsr DrawS_boot        ;store regs to vars (B_LENGTH, P_STR, W_ENDX)
        jsr DrawS_2bit_setup  ;sets W_ONESIZE and W_DATASIZE
        jsr DrawS_initdma
        bra DrawS_common

; ENTRY - Draw string, create 4bit tiles
DrawS_4bit:
        jsr DrawS_boot        ;store regs to vars (B_LENGTH, P_STR, W_ENDX)
        jsr DrawS_4bit_setup  ;sets W_ONESIZE and W_DATASIZE
        jsr DrawS_initdma
        asl
DrawS_common:
.(
        ; Should be 16-bit mode here
        asl
        asl
        asl
        clc:adc W_VRAMADDR
        sta W_VRAMADDR

        SET_8_BIT_A()
CharLoop:
        ; Get a character from string
        lda #$00
        xba
        lda [P_STR]
        beq Zero
        cmp #$01       ; 1 = chars $100..$1FF
        beq ExtraChar
        cmp #$02       ; 2 = chars $200..$2FF
        bne ContinueWithChar
ExtraChar:
        SET_16_BIT_A()
        inc P_STR
        SET_8_BIT_A()
        xba
        lda [P_STR]
ContinueWithChar:
        SET_16_BIT_A()
        inc P_STR
        
        ; Character should be 16bit by now
        jsr Trans
        jsr DrawChar
        ; A-flag undefined now

        ; Print more characters, if desired.
        SET_8_BIT_A()
        dec B_LENGTH
        bne CharLoop

Zero:   .byt $62,2,0  ;there's no indirect-jsr...
        jmp (W_WRITEOFS)   ;write last tile
        
        ; A-flag undefined now

        ; ^FIXME - don't do if PIXOFFS=0

        SET_16_BIT_A()
        
        jmp (W_ENDDRAWS)   ;end of draw-string
.)


DrawS_normalEnd:
.(
        cpx W_ENDX
        bcs DrawS_normalDone     ; if >=
        
        ; Note - If $FF isn't space in the normal 8pix font, change this.
        lda #$FF00 ;byteswapped #$00FF
        SET_8_BIT_A()
        ora $7E    ;attr - from the game
        xba
        SET_16_BIT_A()
        
        tay
DrawS_filler_loop:
        tya
        ;;; FIXME - this doesn't work if WRITEOFS doesn't refer to Write
        jsr WriteOne
        
        SET_16_BIT_A()
        lda W_DATASIZE
        sec:sbc W_ONESIZE
        sta W_DATASIZE  ; decrease the data size
                        ; (generate a smaller dma transfer)
        
        cpx W_ENDX
        bcc DrawS_filler_loop      ; if <

DrawS_normalDone:
        ; Should be 16-bit here

        lda W_VRAMADDR
        sta @$002116 ;Tell PPU what we're going to write

        lda W_DATASIZE
        sta @$004375
        ; ^ dma config size

        SET_8_BIT_A()
        ; Proceed with the DMA that was programmed earlier
        lda #$80
        sta @$00420B
        ; ^ dma proceed - sends data to PPU
        
        ; This is required
        SET_16_BIT_A()
        
        rts
.)



; How ROR works:
;      A += carry<<16
;      carry = A&1
;      A >>= 1
; How ROL works:
;      A <<= 1
;      A += carry
;      carry = A>>16



; DrawChar - draws one character.
;
; Input:
;   M-flag     - must be 16-bit
;   X-flag     - must be 16-bit
;   A          - character to be drawed
;   DB:X       - destination for tile indices
;   B_PIXOFFS  - current pixel position mod 8
;   W_TILENUM  - tile number
;   P_TILEBUF1 - pointer to this tile to be constructed
;   P_TILEBUF2 - pointer to next tile to be constructed
; Output:
;   X          - X+2 if a cell was full
;   P_FONT     - now points to the next tile in font
;   B_PIXOFFS  - incremented by cell width
;   P_TILEBUF1 - incremented by W_ONESIZE
;   P_TILEBUF2 - incremented by W_ONESIZE
;   W_TILENUM  - incremented if a cell was full
; Modifies in undefined way:
;   A
;   Y
;   M-flag

DrawChar:
.(
        .al        ; assumed 16-bit
        .xl
        
        ;Save X - it's used as temporary here and there,
        ;         and must not be changed.
        phx
         ; Save A - we need it later.
         pha
          
          ; Calculate pointer to the current tile in font
          asl
          asl
          asl
          asl
          clc:adc #!TILEDATA_ADDR
          sta P_FONT
          
          ; Calculate X = B_PIXOFFS * 2
          lda B_PIXOFFS
          and #$00FF
          asl
          tax

          ; Handle 8 * 2 bits

          ldy #$0000
          SET_8_BIT_A()
          jmp (tab,x)
          tab .word Handle16bytes_0, Handle16bytes_1
              .word Handle16bytes_2, Handle16bytes_3
              .word Handle16bytes_4, Handle16bytes_5
              .word Handle16bytes_6, Handle16bytes_7
          ; Each of these cases handles 16 bytes.
Handle16bytes_0:
        SET_16_BIT_A()
        ; P_TILEBUF1 = xxxxxxxx P_TILEBUF2 = 00000000  - do direct copy
        lda [P_FONT],y : sta [P_TILEBUF1],y : iny : iny
        lda [P_FONT],y : sta [P_TILEBUF1],y : iny : iny
        lda [P_FONT],y : sta [P_TILEBUF1],y : iny : iny
        lda [P_FONT],y : sta [P_TILEBUF1],y : iny : iny
        lda [P_FONT],y : sta [P_TILEBUF1],y : iny : iny
        lda [P_FONT],y : sta [P_TILEBUF1],y : iny : iny
        lda [P_FONT],y : sta [P_TILEBUF1],y : iny : iny
        lda [P_FONT],y : sta [P_TILEBUF1],y : iny : iny
        bra EndHandle16bytes
#define REST() \
        SET_8_BIT_A() : ora [P_TILEBUF2],y : sta[P_TILEBUF2],y : \
        xba :           ora [P_TILEBUF1],y : sta[P_TILEBUF1],y : iny
Handle16bytes_1:
        ; P_TILEBUF1 = 0xxxxxxx P_TILEBUF2 = x0000000  - do swap;1 lsr
        ; The loop is partially unrolled.
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : REST()
        ;cpy #$0010:; bcc Handle16bytes_1
        bra EndHandle16bytes
Handle16bytes_2:
        ; P_TILEBUF1 = 00xxxxxx P_TILEBUF2 = xx000000  - do swap;2 lsr
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : lsr : REST()
        ;cpy #$0010:; bcc Handle16bytes_2
        bra EndHandle16bytes
Handle16bytes_3:
        ; P_TILEBUF1 = 000xxxxx P_TILEBUF2 = xxx00000  - do swap;3 lsr
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : lsr : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : lsr : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : lsr : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : lsr : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : lsr : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : lsr : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : lsr : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : lsr : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : lsr : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : lsr : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : lsr : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : lsr : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : lsr : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : lsr : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : lsr : lsr : REST()
        .as : lda [P_FONT],y : xba : lda #$00 : SET_16_BIT_A() : lsr : lsr : lsr : REST()
        ;cpy #$0010:; bcc Handle16bytes_3
        bra EndHandle16bytes
Handle16bytes_4:
        ; P_TILEBUF1 = 0000xxxx P_TILEBUF2 = xxxx0000  - do 4 asl
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : asl : asl : REST()
        ;cpy #$0010:; bcc Handle16bytes_4
        bra EndHandle16bytes
Handle16bytes_5:
        ; P_TILEBUF1 = 00000xxx P_TILEBUF2 = xxxxx000  - do 3 asl
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : asl : REST()
        ;cpy #$0010:; bcc Handle16bytes_5
        bra EndHandle16bytes
Handle16bytes_6:
        ; P_TILEBUF1 = 000000xx P_TILEBUF2 = xxxxxx00  - do 2 asl
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : asl : REST()
        ;cpy #$0010:; bcc Handle16bytes_6 
        bra EndHandle16bytes
Handle16bytes_7:
        ; P_TILEBUF1 = 0000000x P_TILEBUF2 = xxxxxxx0  - do 1 asl
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : REST()
        SET_16_BIT_A() : lda [P_FONT],y : and #$00FF : asl : REST()
        ;cpy #$0010:; bcc Handle16bytes_7
        ;bra EndHandle16bytes
#undef REST
       EndHandle16bytes:

          SET_16_BIT_A()
         pla
         
         ; Restored A
         
         ; Update B_PIXOFFS using width_tab[A]
         
         tax
         SET_8_BIT_A()

         lda @WIDTH_ADDR,x
         
         clc:adc B_PIXOFFS
         sta B_PIXOFFS
         ; Note - Must leave B_PIXOFFS to A
        plx
        ; Restored X
        
        ; If B_PIXOFFS >= 8
        cmp #$08
        bcc End ; if <, return.
        
        ; Then &= 7.
        and #$07
        sta B_PIXOFFS
        ; A not important anymore - carry matters

        SET_16_BIT_AX()
        
        ; Increment pointer 1
        lda W_ONESIZE
        clc:adc P_TILEBUF1
        sta P_TILEBUF1
        ; Increment pointer 2
        lda W_ONESIZE
        clc:adc P_TILEBUF2
        sta P_TILEBUF2
        
        jmp (W_WRITEOFS)
.)

; Moves to next tile.
Write:
        SET_16_BIT_A()

        lda W_TILENUM
        inc W_TILENUM
        and #$03FF
        
        SET_8_BIT_A()
        xba
        ora $7E    ;attr - from the game
        xba
        
        SET_16_BIT_A()
        
; Writes one tile index and does X += 2
WriteOne:
	sta !$0000,x
        inx
        inx
End:    rts



; Prepare Draw_*bit functions
; Input
;    Ah:Y = Address of the string
;    Al   = Maximum length of the string (nul terminates earlier)
;    DB:X = Where to put the tile indices
DrawS_boot:
        SET_8_BIT_A()
        sta B_LENGTH     ; Store Al
        xba
        sta P_STR+2      ; Store Ah

        lda #$00
        xba

        SET_16_BIT_AX()
        sty P_STR    ; Store Y
        
        ; Calculate W_ENDX = X + B_LENGTH*2
        asl
        sta W_ENDX
        txa
        clc:adc W_ENDX
        sta W_ENDX   ; And store in W_ENDX
        
        ; Note - X, Y not modified
        ;        A = W_ENDX
        ; A doesn't matter
        ; Y not important anymore, saved in P_STR.
        ; X must be preserved
        rts

DrawS_2bit_setup:
        lda #$0010
        sta W_ONESIZE
        lda B_LENGTH
        and #$00FF
        bra DrawS_setup_common
DrawS_4bit_setup:
        lda #$0020
        sta W_ONESIZE
        lda B_LENGTH
        and #$00FF
        asl ;8*4
DrawS_setup_common:
        asl ;8*2
        asl
        asl
        asl
        sta W_DATASIZE
        rts

DrawS_initdma:
.(
        SET_8_BIT_A()
        
        phb
         pla               ;target page
         sta P_TILEBUF1+2
         sta P_TILEBUF2+2
         pha

         ldy #$0000 ;initialize math register with zero
         
         tya
         pha
         plb        ;now addressing page $00
         
         sty $211B  ;..zero, so that $2134 will give zero for dma
         sty $211B
         
         ;lda #$7F
         ;trb $420C  ; disable H-DMA 4
         
         ldy #$3480 ; $34 = $2134; mode = reading bytes to mem
         sty $4370  ; dma config setup

         lda P_TILEBUF1+2 ;target page
         ldy #TILEBUF     ;target offs = tilebuf
         sty P_TILEBUF1   ;   initialize P_TILEBUF1 while we're here
         
         sty $4372  ; dma config target
         sta $4374

         ldy W_DATASIZE
         lda #$80
         
         sty $4375  ; dma config size
         sta $420B  ; dma proceed - clears TILEBUF
         ;;;
         
         ; Prepare DMA settings for PPU write
         ldy #$1801 ; $18 = $2118; mode = writing words to dev
         sty $4370  ; dma config new setup
         
         ldy #TILEBUF ;source= tilebuf
         sty $4372  ; dma config new source
                    ;  page already set
        plb
.)        ; passthru
DrawS_init_common:
        lda #^TILEDATA_ADDR
        sta P_FONT+2     ; Early handling

        stz B_PIXOFFS

        SET_16_BIT_A()
        
        ; Set up P_TILEBUF2.
        
        lda P_TILEBUF1
        clc:adc W_ONESIZE
        sta P_TILEBUF2

        ; Load W_TILENUM prior to DrawS_common.

        lda W_TILENUM
        rts

DrawS_initnondma:
.(
        SET_16_BIT_A()
        phb
        phb
        pla              ;target page in hi&lo
        sta P_TILEBUF1+1 ;writes to +1 and +2
        sta P_TILEBUF2+1 ;writes to +1 and +2
        
        lda #TILEBUF     ;target offs = tilebuf
        sta P_TILEBUF1   ;   initialize P_TILEBUF1

        sta P_TILEBUF2
        
        lda #$0000
        tay
Loop:
        ; If you want to unroll, choices are 1/2/4/8 lines
        sta (P_TILEBUF2),y : iny : iny
        sta (P_TILEBUF2),y : iny : iny
        sta (P_TILEBUF2),y : iny : iny
        sta (P_TILEBUF2),y : iny : iny
        cpy W_DATASIZE
        bcc Loop

        SET_8_BIT_A()
        bra DrawS_init_common
.)

Trans:
.(
        ; Font8v has been shrunk a bit.
        ; This function translates characters to font indices...
        
        .al
        ; We are 16-bit here

        cmp #$0030
        bcc Special
        ;no sec - it's set here anyway
        ; $80 chars were eaten from the font
        sbc #$0080
        rts
Special:
        sec
        ; itemchars were placed at the beginning
        sbc #$0020
        rts
.)

#define ALLOCATE()        \
        pei ($10) :        \
        pei ($12) :        \
        pei ($14) :        \
        pei ($16) :        \
        pei ($18) :        \
        pei ($1A) :        \
        pei ($1C) :        \
        pei ($1E) :        \
        pei ($20)
#define UNALLOCATE()        \
        pla : sta $20 :        \
        pla : sta $1E :        \
        pla : sta $1C :        \
        pla : sta $1A :        \
        pla : sta $18 :        \
        pla : sta $16 :        \
        pla : sta $14 :        \
        pla : sta $12 :        \
        pla : sta $10

GetItemName:
        ; In - Al=item number
        ; Out- Al=maxlen
        ;      Ah,Y=address of string
        ;
        
        ; This is a copy of the routine at $C2F2E2
        
        SET_16_BIT_AX()
        and #$00FF
        asl
        tay
        lda $7D00,y     ; $7E7D00 HAS ITEM OFFSET LIST.
        tay
        lda #$CC0B      ; ITEMLIST SEGMENT, LENGTH
        ; The table has been built in:
        ;   
        rts
GetItemName2:
        ; In - Al=item number
        ; Out- Al=maxlen
        ;      Ah,Y=address of string
        ;
        ; This is a copy of the code at $C109C1
        SET_16_BIT_A()
        and #$00FF
        sta $84
        asl
        asl
        sta $8E
        asl
        clc:adc $8E
        sec:sbc $84
        clc
        adc #$0B5E  ;ITEM LIST OFFSET
        tay
        lda #$CC0B  ;ITEM LIST SEGMENT, LENGTH
        rts
GetTechName2:
        ; In - Al=item number
        ; Out- Al=maxlen
        ;      Ah,Y=address of string
        ;
        ; This is a copy of the code at $C10B5B
        SET_16_BIT_A()
        and #$00FF
        sta $8E
        asl
        asl
        sta $90
        asl
        clc:adc $90
        sec:sbc $8E
        clc
        adc #$15C4  ;TECH LIST OFFSET
        tay
        lda #$CC0B  ;TECH LIST SEGMENT, LENGTH
        rts

EquipLeftHelper:
.(
        SET_16_BIT_AX()
        phx
         phy
          phk ; to get a far-return 
          jsr GetItemNum
         ply
         lda $04C9
         and #$00FF
         beq Skip
         iny
Skip:   pla
        rtl
GetItemNum:
        lda #$5840
        pha
        .byt $5C, $9A, $A5, $C2  ;jsl $C2A59A
.)

EquipLeftItemFunc:
        ; In - A=item number
        ;      Y=item position in list
        
        SET_16_BIT_AX()
        sty W_TILENUM ;save Y somewhere safe

        jsr GetItemName
        
        SET_8_BIT_A()
        dec ;skip first char
        iny
        SET_16_BIT_A()
        ALLOCATE()
        pha
         lda W_TILENUM
         jsr DoTilenumber_8line
         
         lda #$7000
         sta W_VRAMADDR
        pla
        ;passthru
DisplayFuncCommon_2bit:
        jsr DrawS_2bit
        bra DisplayFuncCommonEnd

EquipRightItemFunc:        ;also used in shop
        ; In - A=item number
.(
        pha
         ; Find out if we were called from the routine
         ; that displays equipment (4 lines)...
         lda 6,s
         cmp #$A70F
         bne Skip1
         sty $22  ; We were. Do a hack, save Y.
         
Skip1:   lda $22   ;counter in create-list
         clc:adc $1041 ;buy-listbegin
         clc:adc $1043 ;sell-listbegin
         ; This works
         sta W_TILENUM
        pla
.)
        SET_16_BIT_AX()
        
        jsr GetItemName
        
        SET_16_BIT_A()
        ALLOCATE()
        pha
         lda W_TILENUM
         jsr DoTilenumber_8line
         
         lda #$0000
         sta W_VRAMADDR
        pla
        bra DisplayFuncCommon_4bit

ItemListFunc:
        ; In - A=item number
        
        ; $000054 (byte) = list scrolling position
        ; 
        
        jsr GetItemName
        
        SET_16_BIT_A()
        ALLOCATE()
        pha
         ; THIS WORKS! PLEASE DON'T BREAK THIS.
         lda $0416  ; scrolling position
         clc:adc $54   ; index in the item list
         and #$00FF
         
         ; Now we have item list scrolling position.
         sta @$004204   ;dividend
         lda #10
         sta @$004206   ;divisor
         ;wait 16 cycles before reading 4216
         lda #$0000
         sta W_VRAMADDR
         lda #Write
         sta W_WRITEOFS
         lda #DrawS_normalEnd
         sta W_ENDDRAWS
         phx
          lda @$004216   ;remainder
          asl
          tax
          lda @TileNumberList,x
         plx
         sta W_TILENUM
        pla
        bra DisplayFuncCommon_4bit

TechListFunc:
        ; In:
        ;    Al     = tech number
        ;    $61    = screen address
        ;    $7700  = table of tech colour attributes
        
        ; C2BDB2 does this:
        
        SET_8_BIT_AX()
        phy ;Save Y...
         
         ; Get tech address AND tech colour code!
         ;
         sta @$004202  ;tech number
         tay
         lda #11
         sta @$004203  ;multiply by 11
         
         ldx #4*3      ;palette 3
         lda $7700,y   ;load tech attribute
         bit #$40
         bne GotAttr
         ldx #4*0      ;palette 0
         bit #$80
         beq GotAttr
         bit $78       ;test if $80 was already given
         bmi GotAttr
         ldx #4*2      ;palette 2
GotAttr:
         stx $7E       ;save attr.
        ply
        
        SET_16_BIT_AX()
        lda #$15C4    ;TECH LIST OFFSET
        
        clc:adc @$004216 ;got technum*11
        ; A is now our source address...
        
        sta W_VRAMADDR ; save source address somewhere
        
        lda #$CC0B    ;TECH LIST SEGMENT $CC, LENGTH $0B

        ALLOCATE()
        pha
         tya        ; Y just happens to be our position in tech list here
                    ;   because we so carefully saved it
         jsr DoTilenumber_8line

         ldy W_VRAMADDR ; Now load the previously saved source address to Y.
         
         lda #$0000
         sta W_VRAMADDR
         lda #Write
         sta W_WRITEOFS
         lda #DrawS_normalEnd
         sta W_ENDDRAWS
        pla

        ldx $61       ;Load screen address (target)

        ;passthru
DisplayFuncCommon_4bit:
        jsr DrawS_4bit
DisplayFuncCommonEnd:
        SET_16_BIT_A()
        UNALLOCATE()
        SET_8_BIT_A()
        
        ; $C2EF65 does this. Resets the attributes (bits $24).
        lda #$DC
        trb $7E
        
        SET_16_BIT_A()
        
        rtl

BattleItemFunc:
        ; Code here
        ;In:
        ;    A = item number
        ;  $86 = item-line counter (ignore)
        ;  $80 = something that runs with step 5, goes to X
        ;  $82 = ($86+1)*128 ?
        ; $1580=table(index with X):
        ;          $1580 = item number
        ;          $1582 = disabled-flags (& $80)
        ;          $1583 = ?
        ;          $1584 = katakana thing
        ;Usable:
        ;  $84 = item number (temp)
        ;  $8E = item number*4 (temp)
        ;Todo:
        ;    write tile numbers to $7E94A0
        ;   VRAM - $7000 = tile table
        ;          $5000 = bitmap table
        ;Assume:
        ;    DB=7E
        ;Can use:
        ;    X, Y, A
        
        SET_16_BIT_AX()
        
        ;ldy #$0B5E
        ;lda #$CC0B
        jsr GetItemName2

        SET_16_BIT_A()
        ALLOCATE()
        
        pha
         lda $80
         and #$00FF

         ; Now we have item list scrolling position.
         sta @$004204   ;dividend
         lda #3
         sta @$004206   ;divisor
         ;wait 16 cycles before reading 4216

         lda #$5000
         sta W_VRAMADDR
         
         lda #BattleWrite
         sta W_WRITEOFS

         lda #BattleWriteEnd
         sta W_ENDDRAWS
         
         phx
          lda @$004216   ;remainder
          asl
          tax
          lda @TileNumberListInBattle,x
         plx
         sta W_TILENUM
         
        pla

        jsr DrawS_boot        ;store regs to vars (B_LENGTH, P_STR, W_ENDX)
        
        ldx #$0000
        
        jsr DrawS_2bit_setup  ;sets W_ONESIZE and W_DATASIZE
        jsr DrawS_initnondma
        jsr DrawS_common
        
        SET_16_BIT_A()
        UNALLOCATE()
        SET_8_BIT_A()
        
        ; Must leave with A=8bit, X=16bit
        rtl

BattleTechFunc:
        ; Code here
        ;In:
        ;    A = item number
        ;  $86 = tech-line counter (ignore)
        ;  $80 = something that runs with step 5, goes to X
        ;  $82 = ($86+1)*128 ?
        ; $1580=table(index with X):
        ;          $1580 = item number
        ;          $1582 = disabled-flags (& $80)
        ;          $1583 = ?
        ;          $1584 = katakana thing
        ;Usable:
        ;  $8E = tech number (temp)
        ;  $90 = tech number*4 (temp)
        ;Todo:
        ;    write tile numbers to $7E94A0
        ;   VRAM - $7000 = tile table
        ;          $5000 = bitmap table
        ;Assume:
        ;    DB=7E
        ;Can use:
        ;    X, Y, A
        SET_16_BIT_AX()
        
        ;ldy #$0B5E
        ;lda #$CC0B
        jsr GetTechName2

        SET_16_BIT_A()
        ALLOCATE()
        
        pha
         lda $80
         and #$00FF

         ; Now we have item list scrolling position.
         sta @$004204   ;dividend
         lda #3
         sta @$004206   ;divisor
         ;wait 16 cycles before reading 4216

         lda #$5000
         sta W_VRAMADDR
         
         lda #BattleWrite
         sta W_WRITEOFS

         lda #BattleWriteEnd
         sta W_ENDDRAWS
         
         phx
          lda @$004216   ;remainder
          asl
          tax
          lda @TileNumberListInBattle,x
         plx
         sta W_TILENUM
         
        pla

        jsr DrawS_boot        ;store regs to vars (B_LENGTH, P_STR, W_ENDX)
        
        ldx #$0000
        
        jsr DrawS_2bit_setup  ;sets W_ONESIZE and W_DATASIZE
        jsr DrawS_initnondma
        jsr DrawS_common
        
        SET_16_BIT_A()
        UNALLOCATE()
        SET_8_BIT_A()
        
        ; Must leave with A=8bit, X=16bit
        rtl


BattleWrite:
        SET_8_BIT_A()
        lda W_TILENUM
        inc W_TILENUM
        sta $94A0,x
        lda #$FF
        sta $94B0,x
        inx
        rts
BattleWriteEnd:
.(
        SET_16_BIT_A()
        
        ; Space-fill the buffer to end
        phx
         cpx #$0010
         bcs +
         SET_8_BIT_A()
         lda #$FF
-        sta $94A0,x
         sta $94B0,x
         inx
         cpx #$0010
         bcc -
         SET_16_BIT_A()
+        lda W_VRAMADDR
         sta @$002116 ; Tell PPU what we think
        pla
        beq DontLoop
        asl
        tay

        ; Send the tiles we created
        phd
         tdc : tax  ; smaller than ldx #$0000
         lda #$2118 ; to PPU
         tcd
-        ; If you want to unroll, choices are 1/2/4/8 lines
         lda TILEBUF+$0,x : sta $00
         lda TILEBUF+$2,x : sta $00
         lda TILEBUF+$4,x : sta $00
         lda TILEBUF+$6,x : sta $00
         txa
         clc:adc #$0008
         tax
         dey
         bne -
        pld
DontLoop:
        rts
.)

DoTilenumber_8line:
         .al
         and #$0007 ; modulo 08
         phx
          asl
          tax
          lda @TileNumberList,x
         plx
         sta W_TILENUM
         lda #Write
         sta W_WRITEOFS
         lda #DrawS_normalEnd
         sta W_ENDDRAWS
         rts

TileNumberList:
        ; All scrolling lists have max of 10 lines.
        ; All of them display maximally 11 tiles wide names.
        ; Here are tilenum starting indices.
        
        .word $0030, $003B, $0046, $0051, $005C
        .word $0067, $0072, $007D, $0088, $0093

TileNumberListInBattle:
        .word $0150, $018A, $0195
