; Part of Chronotools - http;//bisqwit.iki.fi/source/chronotools.html
;
; Copyright (C) 1992,2003 Bisqwit (http;//iki.fi/bisqwit/)
;
; This code draws text using VWF8 (variable width 8pix tall font).
;
; To be assembled with xa65.
;    http;//www.floodgap.com/retrotech/xa/
;

; Note - Caller is assumed to use PEI .
;   The functions to be called are:
;        DrawS_2bit - for 2bit screens
;        DrawS_4bit - for 4bit screens
;   See DrawS_init for register usage.

; TODO:
;   "you dont need to save DB
;    it's mirrored remember"


; Params from the caller - must be set:
#define W_TILENUM  $10
#define W_VRAMADDR $12

; Own things:
#define P_STR      $14
#define P_FONT     $17
#define B_PIXOFFS  $1A
#define B_LENGTH   $1B
#define W_ENDX     $1C
#define P_TILEBUF1 $1E
#define P_TILEBUF2 $21
#define W_DATASIZE $24
#define W_ONESIZE  $26

; Tilebuf is at $7E6200 - size maximally 11*64 bytes
#define TILEBUF   $6200

; External symbols - defined by the linker:
;   Font address:
;    TILEDATA_OFFS - CONST
;    TILEDATA_SEG  - CONST
;   Width table address:
;    WIDTH_OFFS    - CONST
;    WIDTH_SEG     - CONST

.text
.xl

; Define functions for handling the bitness...
#define SET_8_BIT_A()   sep #$20 : .as
#define SET_16_BIT_A()  rep #$20 : .al
#define SET_8_BIT_X()   sep #$10 : .xs
#define SET_16_BIT_X()  rep #$10 : .xl

#define SET_8_BIT_AX()  sep #$30 : .xs : .as
#define SET_16_BIT_AX() rep #$30 : .xl : .al


; -- CURRENTLY --
; Input:
;    xxxxxxxx
;
; ofs  2nd byte 1st byte
;  0   xxxxxxxx 00000000 handled
;  1   0xxxxxxx x0000000 xba; 1 lsr
;  2   00xxxxxx xx000000 xba; 2 lsr
;  3   000xxxxx xxx00000 xba; 3 lsr
;  4   0000xxxx xxxx0000 4 asl
;  5   00000xxx xxxxx000 3 asl
;  6   000000xx xxxxxx00 2 asl
;  7   0000000x xxxxxxx0 1 asl

; -- PLANNING --
; When handling two bytes at time:
; Input:
;     byte2    byte1
;    yyyyyyyyxxxxxxxx
; 
; Results should be (when ofs 0..7):
; ofs    second word       first word  
;  0  yyyyyyyyxxxxxxxx 0000000000000000
;  1  0yyyyyyy0xxxxxxx y0000000x0000000
;  2  00yyyyyy00xxxxxx yy000000xx000000
;  3  000yyyyy000xxxxx yyy00000xxx00000
;  4  0000yyyy0000xxxx yyyy0000xxxx0000
;  5  00000yyy00000xxx yyyyy000xxxxx000
;  6  000000yy000000xx yyyyyy00xxxxxx00
;  7  0000000y0000000x yyyyyyy0xxxxxxx0

; -- PLANNING --
; How ROR works:
;      A += carry<<16
;      carry = A&1
;      A >>= 1
; How ROL works:
;      A <<= 1
;      A += carry
;      carry = A>>16

; -- PLANNING --
;  SET_8BIT_A
;              VAR       A
;            00000000-xxxxxxxx
;    asl     00000000-xxxxxxx0
;    rol VAR 0000000x-xxxxxxx0


; ONEBIT - handles one BYTE of a 16-byte font tile.
;
; Input:
;   X-flag     - must be 16-bit
;   X          = PIXOFFS*2
;   P_FONT     = pointer to the current tile in font
;   Y          = index of the current byte in font
;   P_TILEBUF1 = pointer to this tile to be constructed
;   P_TILEBUF2 = pointer to next tile to be constructed
; Output:
;   Y      = Y+1
;   M-flag - 8-bit
; Leaves undefined:
;   A

#define ONEBIT()   \
.(                         : \
        rep #$20 : .al     : \
        lda [P_FONT],y     : \
        and #$00FF         : \
        jmp (tab,x)        : \
                           : \
    tab .word s0,s1,s2,s3,s4,s5,s6,s7   : \
                                        : \
    s0  sep #$20: .as : bra End2        : \
    s1  xba :             lsr : bra End : \
    s2  xba :       lsr : lsr : bra End : \
    s3  asl                : \
    s4  asl                : \
    s5  asl                : \
    s6  asl                : \
    s7  asl                : \
                           : \
    End:                   : \
        sep #$20 : .as     : \
        ora [P_TILEBUF2],y : \
        sta [P_TILEBUF2],y : \
        xba                : \
        ora [P_TILEBUF1],y : \
    End2:                  : \
        sta [P_TILEBUF1],y : \
        iny                : \
.)


; DrawChar - draws one character.
;
; Input:
;   M-flag     - must be 16-bit
;   X-flag     - must be 16-bit
;   A          - character to be drawed
;   DB,X       - destination for tile indices
;   Y          - index of the current byte in font
;   B_PIXOFFS  - current pixel position mod 8
;   W_TILENUM  - tile number
;   P_TILEBUF1 - pointer to this tile to be constructed
;   P_TILEBUF2 - pointer to next tile to be constructed
; Output:
;   X          - X+2 if a cell was full
;   P_FONT     - now points to the next tile in font
;   B_PIXOFFS  - incremented by cell width
;   P_TILEBUF1 - incremented by W_ONESIZE
;   P_TILEBUF2 - incremented by W_ONESIZE
;   W_TILENUM  - incremented if a cell was full
; Leaves undefined:
;   A
;   Y
;   M-flag

DrawChar:
        .al        ; assumed 16-bit
        .xl
        
        ;Save X - it's used as temporary here and there,
        ;         and must not be changed.
        phx
         ; Save A - we need it later.
         pha
          
          ; Calculate pointer to the current tile in font
          asl
          asl
          asl
          asl
          clc
          adc #TILEDATA_OFFS
          sta P_FONT
          
          ; Calculate X = B_PIXOFFS * 2
          lda B_PIXOFFS
          and #$00FF
          asl
          tax

          ; Handle 8 * 2 bits

          ldy #$0000
          
          ONEBIT()
          ONEBIT()
          ONEBIT()
          ONEBIT()
          
          ONEBIT()
          ONEBIT()
          ONEBIT()
          ONEBIT()
          
          ONEBIT()
          ONEBIT()
          ONEBIT()
          ONEBIT()
          
          ONEBIT()
          ONEBIT()
          ONEBIT()
          ONEBIT()
          
          SET_16_BIT_A()
         pla
         
         ; Restored A
         
         ; Update B_PIXOFFS using width_tab[A]
         
         tax
         SET_8_BIT_A()
          
         .byt $BF
         .word WIDTH_OFFS
         .byt  <WIDTH_SEG
         ;^doesn't work -  lda @WIDTH_ADDR,x
         
         clc
         adc B_PIXOFFS
         sta B_PIXOFFS
         ; Note - Must leave B_PIXOFFS to A
        plx
        ; Restored X
        
        ; If B_PIXOFFS >= 8
        cmp #$08
        bcc End ; if <
        
        ; Then &= 7.
        and #$07
        sta B_PIXOFFS
        ; A not important anymore - carry matters

        SET_16_BIT_AX()
        
        ; Increment pointer 1
        lda W_ONESIZE
        clc
        adc P_TILEBUF1
        sta P_TILEBUF1
        ; Increment pointer 2
        lda W_ONESIZE
        clc
        adc P_TILEBUF2
        sta P_TILEBUF2

; Moves to next tile.
Write:
        SET_16_BIT_A()

        lda W_TILENUM
        inc W_TILENUM
        and #$03FF
        
        SET_8_BIT_A()
        xba
        ora $7E    ;attr - from the game
        xba
        
        SET_16_BIT_A()
        
; Writes one tile index and does X += 2
WriteOne:
        .byt $9D,$00,$00
        ; Using .byt because "sta !$0000,x" doesn't work
        inx
        inx
End:    rts



; Prepare Draw_*bit functions
; Input
;    Ah,Y = Address of the string
;    Al   = Maximum length of the string (nul terminates earlier)
;    DB,X = Where to put the tile indices
DrawS_init:
        SET_8_BIT_A()
        sta B_LENGTH     ; Store Al
        xba
        sta P_STR+2      ; Store Ah

        lda #<TILEDATA_SEG
        sta P_FONT+2     ; Early handling

        lda #$00
        xba

        stz B_PIXOFFS

        SET_16_BIT_AX()
        sty P_STR    ; Store Y
        
        ; Load the maximum length * 2
        asl
        sta W_ENDX
        txa         ; Add X
        clc
        adc W_ENDX
        sta W_ENDX   ; And store in W_ENDX
        
        ; Note - X, Y not modified
        ;        A = W_ENDX
        ; A doesn't matter
        ; Y not important anymore, saved in P_STR.
        ; X must be preserved
        rts

DrawS_2bit_getdatasize:
        lda #$0010
        sta W_ONESIZE
        lda B_LENGTH
        and #$00FF
        bra GetDataSizeEnd
DrawS_4bit_getdatasize:
        lda #$0020
        sta W_ONESIZE
        lda B_LENGTH
        and #$00FF
        asl ;8*4
GetDataSizeEnd:
        asl ;8*2
        asl
        asl
        asl
        sta W_DATASIZE
        rts

DrawS_initdma:
        phb
         SET_8_BIT_A()
         pla               ;target page
         sta P_TILEBUF1+2
         sta P_TILEBUF2+2
         pha

         lda #$00
         pha
         plb        ;now addressing page $00
         
         ldy #$000  ;initialize math register with zero
         sty $211B  ;so that $2134 will give zero for dma
         sty $211B
         
         ldy #$3480 ; $34 = $2134; mode = bytes,writing
         sty $4370  ; dma config setup

         lda P_TILEBUF1+2 ;target page
         ldy #TILEBUF     ;target offs = tilebuf
         sty P_TILEBUF1
         
         sty $4372  ; dma config target
         sta $4374

         ldy W_DATASIZE
         lda #$80
         sty $4375  ; dma config size
         sta $420B  ; dma proceed - clears TILEBUF
         
         ; Prepare DMA settings for WriteLow
         ldy #$1801 ; $18 = $2118; mode = words,reading
         sty $4370  ; dma config new setup
         
         ldy #TILEBUF ;source= tilebuf
         sty $4372  ; dma config new source
        plb

        SET_16_BIT_A()
        
        ; Set up P_TILEBUF2.
        
        lda P_TILEBUF1
        clc
        adc W_ONESIZE
        sta P_TILEBUF2

        ; Load W_TILENUM prior to DrawS_common.

        lda W_TILENUM
        rts

; Draw string, create 2bit tiles
DrawS_2bit:
        jsr DrawS_init  ;store registers to vars
        jsr DrawS_2bit_getdatasize
        jsr DrawS_initdma
        bra DrawS_common

; Draw string, create 4bit tiles
DrawS_4bit:
        jsr DrawS_init  ;store registers to vars
        jsr DrawS_4bit_getdatasize
        jsr DrawS_initdma
        asl
DrawS_common:
.(
        ; Should be 16-bit mode here
        asl
        asl
        asl
        clc
        adc W_VRAMADDR
        .byt $8F,$16,$21,$00   ;sta $002116

        SET_8_BIT_A()
CharLoop:
        ; Get a character from string
        lda #$00
        xba
        lda [P_STR]
        beq Zero
        cmp #$01       ; 1 = chars $100..$1FF
        beq ExtraChar
        cmp #$02       ; 2 = chars $200..$2FF
        bne ContinueWithChar
ExtraChar:
        SET_16_BIT_A()
        inc P_STR
        SET_8_BIT_A()
        xba
        lda [P_STR]
ContinueWithChar:
        SET_16_BIT_A()
        inc P_STR
        
        ; Character should be 16bit by now
        jsr Trans
        jsr DrawChar

        ; Move to next character. Set Z-flag if end of string
        SET_8_BIT_A()
        dec B_LENGTH
        bne CharLoop

Zero:   jsr Write ; write last tile
        ; ^FIXME - don't do if PIXOFFS=0

        SET_16_BIT_A()
        
        cpx W_ENDX
        bcs EndDrawS     ; if >=
        
        ; Note - If $FF isn't space in the normal 8pix font, change this.
        lda #$FF00 ;byteswapped #$00FF
        SET_8_BIT_A()
        ora $7E    ;attr - from the game
        xba
        SET_16_BIT_A()
        
        tay
EndLoop:
        tya
        jsr WriteOne
        
        lda W_DATASIZE
        sec
        sbc W_ONESIZE
        sta W_DATASIZE  ; decrease the data size
                        ; (generate a smaller dma transfer)
        
        cpx W_ENDX
        bcc EndLoop      ; if <

EndDrawS:
        ; Should be 16-bit here
        lda W_DATASIZE
        .byt $8F,$75,$43,$00   ;sta $004375
        ; ^ dma config size

        SET_8_BIT_A()
        ; Proceed with the DMA that was programmed earlier
        lda #$80
        .byt $8F,$0B,$42,$00   ;sta $00420B
        ; ^ dma proceed - sends data to PPU
        
        ; This is required
        SET_16_BIT_A()
        
        rtl
.)

Trans:
.(
        ; Font8v has been shrunk a bit.
        ; This function translates characters to font indices...
        
        .al
        ; We are 16-bit here

        cmp #$0030
        bcc Special
        ;no sec - it's set here anyway
        ; $80 chars were eaten from the font
        sbc #$0080
        rts
Special:
        sec
        ; itemchars were placed at the beginning
        sbc #$0020
        rts
.)
