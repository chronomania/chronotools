#
# This file is derived from taipus.cc, and attempts to describe
# the algorithm so that it's translatable in asm.
# 
# It is responsible of conjugating names in the game.
#
#  Syntax
#
#  :B name
#     declare function returning boolean, handles character name
#  :Q name
#     declare function returning boolean, parameter is byte (assigned to 'c')
#  :I name
#     declare function returning byte
## OUT name
#     Outputs character in name
## VAR name
#     local variable
## s name1 value/name2
#     assign name1 from value
## + name
#     name++
## - name
#     name--
## { 
#     loop over character name, character as 'c'
## }
#     end character name loop
## ? characters
#     If c is in set, process subblock
## > name value/name2
#     if(name > value), process subblock
## = name value/name2
#     if(name == value), process subblock
## TRUE
#     For boolean funcs, return TRUE
## FALSE
#     For boolean funcs, return FALSE
## RET
#     For boolean funcs, just return
## RETURN name
#     For byte funcs, return value of var
## ci name1 name2
#     Call integer-func name1, return value to name2.
## cb name1
#     Call bool-func name1
#     Process subblock if true retval
## cq name1 name2
#     Call bool-func name1 with param name2
#     Process subblock if true retval
## cv name1 name2
#     Call bool-func name1 with param name2
#     Ignore return value
## cf name
#     Call bool-func name
#     Ignore return value

:Q IsVowel
? aeiouy‰ˆÂÈAEIOUYƒ÷≈…0123456
  TRUE
FALSE

:Q IsKPT
? kKpPtT
  TRUE
FALSE

:B IsFront
VAR VowelType FoundE Finalguess
s VowelType 0
s FoundE 0
s Finalguess 0
{
s Finalguess 1
? aouAOU02368
  s VowelType 1
? ‰ˆyƒ÷Y14579
  s VowelType 2
? eiÈEI…
  s FoundE 1
? hkqÂHKQ≈
  s Finalguess 0
}
= VowelType 2
  TRUE
= VowelType 1
  FALSE
= FoundE 1
  TRUE
= Finalguess 1
  TRUE
FALSE

:I Length
VAR Len
s Len 0
{
+ Len
}
RETURN Len

:I LastChar3
VAR Hint1 Hint2 Hint3
s Hint1 0
s Hint2 0
s Hint3 0
{
  s Hint3 Hint2
  s Hint2 Hint1
  s Hint1 c
}
RETURN Hint3

:I LastChar2
VAR Hint1 Hint2
s Hint1 0
s Hint2 0
{
  s Hint2 Hint1
  s Hint1 c
}
RETURN Hint2

:I LastChar1
VAR Hint1
s Hint1 0
{
  s Hint1 c
}
RETURN Hint1

:B IsAbbrev
VAR Len Vowels WasVowel ElseFlag
s Len 0
s Vowels 0
s WasVowel 0
{
  + Len
  s ElseFlag 1
  ? aeiouy‰ˆÂÈAEIOUYƒ÷≈…
    s Vowels 1
    s WasVowel 1
    s ElseFlag 0
  ? 0123456789
# Number after a vowel means "no vowels"
    = WasVowel 1
      s Vowels 0
    s WasVowel 0
    s ElseFlag 0
  = ElseFlag 1
    s WasVowel 0
}
= Len 1
  TRUE
= Vowels 0
  TRUE
FALSE

:B IsEs
VAR Hint
ci LastChar2 Hint
cq IsVowel Hint
  ci LastChar1 c
  ? sS
    TRUE
FALSE

:B EndWithVowel
VAR Hint
ci LastChar1 Hint
cq IsVowel Hint
  TRUE
FALSE

:B DoubleHard
VAR Hint2 Hint3
cb EndWithVowel
  ci LastChar2 Hint2
  ci LastChar3 Hint3
  = Hint2 Hint3
    cq IsKPT Hint2
      TRUE
FALSE

:B AkiEnd
VAR Hint
ci LastChar3 c
? aA‰ƒ
  ci LastChar2 Hint
  cq IsKPT Hint
    ci LastChar1 c
    ? iI
      TRUE
FALSE

:Q OutWord
VAR Hint
s Hint c
{
  = Hint 0
    RET
  OUT c
  - Hint
}
RET

:B HardStem
VAR Len Hint Hint2
ci Length Len
cb IsAbbrev
  cv OutWord Len
  OUT ':'
  ci LastChar1 Hint
  s Hint2 0
  ? flmnrswxFLMNRSWX479
    OUT '‰'
    s Hint2 1
  ? zZ
    OUT 'a'
    s Hint2 1
  ? 0123568
    RET
  = Hint2 0
    OUT 't'
  RET
cb IsEs
  cv OutWord Len
  OUT 't'
  RET
cb EndWithVowel
  cb AkiEnd
    - Len
    cv OutWord Len
    OUT 'e'
    RET
  cv OutWord Len
  RET
cv OutWord Len
OUT 'i'
RET

:B SoftStem
VAR Len Hint
ci Length Len
cb IsAbbrev
  cv OutWord Len
  OUT ':'
  RET
cb IsEs
  - Len
  cv OutWord Len
  OUT 'k'
  OUT 's'
  OUT 'e'
  RET
cb EndWithVowel
  cb DoubleHard
    - Len
    - Len
    cv OutWord Len
    ci LastChar1 Hint
    OUT Hint
    RET
  cb AkiEnd
    - Len
    - Len
    cv OutWord Len
    OUT 'e'
    RET
  cv OutWord Len
  RET
cv OutWord Len
OUT 'i'
RET

:B Out_A no_vars
cb IsFront
  OUT '‰'
  RET
OUT 'a'
RET

:B Do_N no_vars
cf SoftStem
OUT 'n'
RET

:B Do_A no_vars
cf HardStem
cf Out_A
RET

:B Do_LLA no_vars
cf SoftStem
OUT 'l'
OUT 'l'
cf Out_A
RET

:B Do_LLE no_vars
cf SoftStem
OUT 'l'
OUT 'l'
OUT 'e'
RET

:B Do_STA no_vars
cf SoftStem
OUT 's'
OUT 't'
cf Out_A
RET

# -- End --
