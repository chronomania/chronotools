#
# This file is derived from taipus.cc, and attempts to describe
# the algorithm so that it's translatable in asm.
# 
# It is responsible of conjugating names in the game.
#
#  Syntax
#
#  :func_b name
#     declare function returning boolean.
#     If parameter given, it's assigned to variable "c".
#  :func_i name
#     declare function returning byte
## OUT name
#     Outputs character in name
## VAR name..
#     define local variables
## REG name..
#     define register variables
## LET name1 value/name2
#     assign name1 from value
## INC name
#     name++
## DEC name
#     name--
## { 
#     loop over character name, store current character in variable "c"
## }
#     end character name loop
## ? name characters
#     If name is in set, process subblock
## > name value/name2
#     if(name > value), process subblock
## = name value/name2
#     if(name == value), process subblock
## TRUE
#     For boolean funcs, return TRUE
## FALSE
#     For boolean funcs, return FALSE
## RET
#     For boolean funcs, just return
## RETURN name
#     For byte funcs, return value of var
## IF name1 name2
#     Call bool-func name1
#     If name2 given, will be passed as param.
#     Process subblock if true retval
## CALL_GET name1 name2
#     Call integer-func name1, return value to name2.
## CALL name1 name2
#     Call bool-func name1
#     If name2 given, will be passed as param.
#     Ignore return value

:func_b IsVowel
REG c
? c aeiouy‰ˆÂÈAEIOUYƒ÷≈…0123456
  TRUE
FALSE

:func_b IsKPT
REG c
? c kKpPtT
  TRUE
FALSE

:func_b IsFront
VAR VowelType FoundE Finalguess c
LET VowelType 0
LET FoundE 0
LET Finalguess 0
{
  LET Finalguess 1
  ? c aouAOU02368
    LET VowelType 1
  ? c ‰ˆyƒ÷Y14579
    LET VowelType 2
  ? c eiÈEI…
    LET FoundE 1
  ? c hkqÂHKQ≈
    LET Finalguess 0
}
= VowelType 2
  TRUE
= VowelType 1
  FALSE
= FoundE 1
  TRUE
= Finalguess 1
  TRUE
FALSE

:func_i Length
VAR Len
REG c
LET Len 0
{
  INC Len
}
RETURN Len

:func_i LastChar3
VAR c1 c2 c3 c
LET c1 0
LET c2 0
LET c3 0
{
  LET c3 c2
  LET c2 c1
  LET c1 c
}
RETURN c3

:func_i LastChar2
VAR c1 c2 c
LET c1 0
LET c2 0
{
  LET c2 c1
  LET c1 c
}
RETURN c2

:func_i LastChar1
VAR c1
REG c
LET c1 0
{
  LET c1 c
}
RETURN c1

:func_b IsAbbrev
VAR Len Vowels WasVowel ElseFlag c
LET Len 0
LET Vowels 0
LET WasVowel 0
{
  INC Len
  LET ElseFlag 1
  ? c aeiouy‰ˆÂÈAEIOUYƒ÷≈…
    LET Vowels 1
    LET WasVowel 1
    LET ElseFlag 0
  ? c 0123456789
    = WasVowel 1
      LET Vowels 0
    #s WasVowel 0
    #s ElseFlag 0
  = ElseFlag 1
    LET WasVowel 0
}
= Len 1
  TRUE
= Vowels 0
  TRUE
FALSE

:func_b IsEs
REG c2 c
CALL_GET LastChar2 c2
IF IsVowel c2
  CALL_GET LastChar1 c
  ? c sS
    TRUE
FALSE

:func_b EndWithVowel
REG c1
CALL_GET LastChar1 c1
IF IsVowel c1
  TRUE
FALSE

:func_b DoubleHard
VAR c3
REG c2
IF EndWithVowel
  CALL_GET LastChar3 c3
  CALL_GET LastChar2 c2
  = c3 c2
    IF IsKPT c2
      TRUE
FALSE

:func_b AkiEnd
REG c3 c2 c1
CALL_GET LastChar3 c3
? c3 aA‰ƒ
  CALL_GET LastChar2 c2
  IF IsKPT c2
    CALL_GET LastChar1 c1
    ? c1 iI
      TRUE
FALSE

:func_b OutWord
VAR left c
LET left c
{
  = left 0
    RET
  OUT c
  DEC left
}
RET

:func_b HardStem
VAR Len CaseFound c
CALL_GET Length Len
IF IsAbbrev
  CALL OutWord Len
  OUT ':'
  LET CaseFound 0
  CALL_GET LastChar1 c
  ? c flmnrswxFLMNRSWX479
    OUT '‰'
    LET CaseFound 1
  ? c zZ
    OUT 'a'
    LET CaseFound 1
  ? c 0123568
    RET
  = CaseFound 0
    OUT 't'
  RET
IF IsEs
  CALL OutWord Len
  OUT 't'
  RET
IF EndWithVowel
  IF AkiEnd
    DEC Len
    CALL OutWord Len
    OUT 'e'
    RET
  CALL OutWord Len
  RET
CALL OutWord Len
OUT 'i'
RET

:func_b SoftStem
VAR Len
REG chr
CALL_GET Length Len
IF IsAbbrev
  CALL OutWord Len
  OUT ':'
  RET
IF IsEs
  DEC Len
  CALL OutWord Len
  OUT 'k'
  OUT 's'
  OUT 'e'
  RET
IF EndWithVowel
  IF DoubleHard
    DEC Len
    DEC Len
    CALL OutWord Len
    CALL_GET LastChar1 chr
    OUT chr
    RET
  IF AkiEnd
    DEC Len
    DEC Len
    CALL OutWord Len
    OUT 'e'
    RET
  CALL OutWord Len
  RET
CALL OutWord Len
OUT 'i'
RET

:func_b Out_A
IF IsFront
  OUT '‰'
  RET
OUT 'a'
RET

:func_b Do_N
CALL SoftStem
OUT 'n'
RET

:func_b Do_A
CALL HardStem
CALL Out_A
RET

:func_b Do_LLA
CALL SoftStem
OUT 'l'
OUT 'l'
CALL Out_A
RET

:func_b Do_LLE
CALL SoftStem
OUT 'l'
OUT 'l'
OUT 'e'
RET

:func_b Do_STA
CALL SoftStem
OUT 's'
OUT 't'
CALL Out_A
RET

# -- End --
